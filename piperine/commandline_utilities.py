
from __future__ import division, print_function

import sys
import os
import os.path
import re
import importlib
import pkg_resources
import time
import csv

import numpy as np

from . import Srinivas2017 as default_translation_scheme
from .designer import run_designer, get_parameters_from_crn_file, score_fixed

if sys.version_info >= (3,0):
    from io import StringIO
else:
    from StringIO import StringIO

class Capturing(list):
    def __enter__(self):
        self._stdout = sys.stdout
        sys.stdout = self._stringio = StringIO()
        return self
    def __exit__(self, *args):
        self.extend(self._stringio.getvalue().splitlines())
        sys.stdout = self._stdout

default_energyfuncs = default_translation_scheme.energetics.energyfuncs()
default_translation = default_translation_scheme.translation
default_design_params = default_translation_scheme.translation.default_params
small_crn = pkg_resources.resource_filename('piperine', "data/small.crn")
data_dir = os.path.dirname(small_crn)

opt_methods = ['worst-rank', 'worst-weighted-rank', 'sum-of-ranks', 'sum-of-weighted-ranks', 'fractional excess sum',
               'weighted fractional excess sum', 'percet badness sum', 'weighted percent badness sum', 'sum-of-metaranks']

def get_design_parser():
    import argparse
    descr = '\
piperine-design is the command-line utility for compiling CRNs into DNA sequences using Piperine. From this utility, \
users can specify the domain length parameters, toehold energetics, and translation scheme. The outputs of this utility \
are the sequences of candidate DNA implementations, a table of scores calculated by heuristic measures of sequence quality, \
and a comparison of the candidates based on their heuristic scores. Piperine generates and scores multiple candidates during \
an execution (default is 4 candidates). The utility announces the candidate that Piperine considers to be the best.'

    usage = "\n" + descr + "\n\n\
The following is the call template with short option flags. Options are shown in brackets. Capitalized terms stand in for \
arguments. Ellipses indicate multiple arguments accepted.\n\n\
piperine-design CRNFILE [-h] [-l LENGTH] [-e ENERGY] [-d DEVIATION] [-m MAXSPURIOUS] \
[-p DESIGNPARAMS ...] [-n CANDIDATES] \
[-t TRANSLATION] [-x EXTRAPARS] [-q] \n\n\
Default execution parameters are stated in the option descriptions. The following are example executions using the CRN \
file my_very_own.crn and option arguments to override the default settings. Files generated will have the same file name \
as the .crn file, but have different extensions (e.g. my_very_own0_strands.txt, my_very_own0.seqs, my_very_own_score_report.txt). \
    \n\n\
    Design four sets of sequences for the my_very_own.crn according to the default translation scheme, Srinivas2017:\n \n\
    piperine-design my_very_own.crn\n \
\n \
\n\
    Design 10 sequence sets for my_very_own.crn:\n\n\
    piperine-design my_very_own.crn -n 10\n\
\n \
\n\
    Override default domain lengths for the default translation scheme:\n\n\
    piperine-design my_very_own.crn --designparams 5 20 2 \n\
\n \
\n\
    Design four set of sequences for my_very_own.crn according to the Chen2013 translation scheme:\n\n\
    piperine-design my_very_own.crn -t Chen2013\n\
    or\n\
    piperine-design my_very_own.crn --translation_scheme Chen2013\n\
    \n \n\
    Override default domain lengths for the Chen2013 translation scheme:\n\n\
    piperine-design my_very_own.crn --designparams 5 20 --translation_scheme Chen2013\n\n\
Parameters may also be set in the CRN file using equality statements and the following terms \
(e.g. toehold_energy=7.5):\n\
    - toehold_energy\n\
    - toehold_deviation\n\
    - toehold_spurious\n\
    - toehold_length\n\
    - spurious_design_parameters\n\
    - translation_scheme\n\
    - n\n\
Arguments passed to piperine-design in the command line take precedence over those specified in \
the CRN file.\n"
    parser = argparse.ArgumentParser(usage=usage)
    parser.add_argument("crnfile",
                        help='Text file describing CRN. May also define parameters. Files read or generated by ' +
                              'this call will have the form: basename.extension ; '+
                          'E.g. basename_score_report.txt, basename.pil, when the crn file is basename.crn.',
                        type=str)

    parser.add_argument("-l", "--length",
                        help='Integer specifying toehold length in nucleotides. [default: Taken from translation scheme package]',
                        type=int)

    parser.add_argument("-e", "--energy",
                        help='Target toehold binding energy used by StickyDesign, '+
                        'in kcal/mol. [default: 7.7]',
                        type=float)

    parser.add_argument("-d", "--deviation",
                        help='Maximum standard deviation for toehold binding energies allowed by StickyDesign'+
                            ', in kcal/mol. [default: 0.5]',
                        type=float)

    parser.add_argument("-m", "--maxspurious",
                        help='This argument is passed to StickyDesign and sets the Maximum spurious interac'+
                        'tion energy as a multiple of target binding energy. [default: '+
                        '0.4]',
                        type=float)

    parser.add_argument("-p", '--designparams',
                        help='A string of integers that are parameters to the sys file compilation. [default: Finds in '+
                             'translation scheme package]',
                        type=int,
                        nargs="*")

    parser.add_argument("-n", '--candidates',
                        help='Number of candidate sequences to generate. [default: 4]',
                        type=int)

    parser.add_argument("-O", '--optimizer',
                        help='Method used by the selection process to choose the optimal candidate. Options are {}.'.format(opt_methods) +\
                             ' [default: sum-of-metaranks]',
                        type=str)

    parser.add_argument("-t", '--translation_scheme',
                        help='Provide a string, the name of the Python package describing the translation scheme used to convert'+
                            'the CRN to DNA strands and complexes. See piperine.Srinivas2017 for an example of such a package.'+
                            ' Chen2013 and Srinivas2017 are provided with Piperine. [default: Srinivas2017]',
                        type=str)

    parser.add_argument("-x", '--extrapars',
                        help='Parameters sent to SpuriousSSM. Common parameters include "bored", "imax", "tmax" and \
                              can be set by supplying equality statements e.g. "bored=500". [default: None]',
                        type=str)

    parser.add_argument("-q", '--quick',
                        action='store_true',
                        help='Debugging mode that speeds up sequence generation and uses random numbers instead of '+
                             'computing heuristics. [default: False]')

    parser.add_argument("-D", '--debug',
                        action='store_true',
                        help='Debugging mode that preserves intermediate compilation files. [default: False]')
    return parser


def design():
    '''
    Function called by the command line function 'piperine-design'
    '''
    parser = get_design_parser()
    args = parser.parse_args()

    ############## Interpret arguments.
    # Precedence is : command line arguments > crn file arguments > default
    try:
        assert(os.path.isfile(args.crnfile))
    except:
        print('Input file {} does not exist'.format(args.crnfile))
        exit()

    if args.crnfile[-4:] == '.crn':
        basename = args.crnfile[:-4]
        crnfile = args.crnfile
    else:
        basename = args.crnfile.split('.')[0]
        crnfile = args.crnfile[:]

    # Find absolute path to basename
    basedir = os.path.dirname(basename)
    if basedir == '':
        basename = os.getcwd() + os.path.sep + basename
        crnfile = os.getcwd() + os.path.sep + args.crnfile

    # Read parameters from CRN file, only to see if translation scheme is defined
    parameters = get_parameters_from_crn_file(crnfile, None)

    # Import translation scheme package
    available_schemes = ["Srinivas2017","Chen2013"]
    if args.translation_scheme in available_schemes :
        translation_scheme = importlib.import_module("."+args.translation_scheme, 'piperine')
    elif 'translation_scheme' in parameters:
        translation_scheme = importlib.import_module("."+parameters['translation_scheme'], 'piperine')
    elif args.translation_scheme is None:
        translation_scheme = default_translation_scheme
    else:
        print("Invalid translation scheme. Choose betweeen {}".format(available_schemes))
        exit()

    # Sorry for this horrible line. "translation_scheme" is a package that holds the
    # translation and energetics modules. "translation" is a module that provides the code
    # that generates PIL descriptions of the DNA implementation.
    translation = translation_scheme.translation

    # Read parameters again to retrieve design parameters
    crn_file_parameters = get_parameters_from_crn_file(crnfile, translation)

    # Make dictionary for design parameters. Start with default parameters
    design_param_dict = dict(zip(translation.param_terms, translation.default_params))

    # Apply parameter option preference
    for term in translation.param_terms:
        if term in crn_file_parameters:
            design_param_dict[term] = crn_file_parameters[term]

    if args.designparams:
        design_param_dict = dict(zip(translation.param_terms, args.designparams))

    if args.length:
        toehold_length = args.length
    elif args.designparams:
        toehold_length = design_param_dict[translation.toehold_length_term]
    elif 'toehold_length' in parameters:
        toehold_length = parameters['toehold_length']
    elif translation.toehold_length_term in parameters:
        toehold_length = parameters[translation.toehold_length_term]
    else:
        toehold_length = design_param_dict[translation.toehold_length_term]

    try:
        assert(toehold_length == design_param_dict[translation.toehold_length_term])
    except AssertionError:
        if args.length and args.designparams:
            message = "Toehold length contradiction in input arguments. Toehold length specified by --length or within CRN file:{}, "+\
                      "toehold length specified by design parameters: {}. Proceeding with {}."
            design_th_length = design_param_dict[translation.toehold_length_term]
            toehold_length = design_th_length
            print(message.format(toehold_length, design_th_length, toehold_length))
            time.sleep(4)
        else:
            design_param_dict[translation.toehold_length_term] = toehold_length

    design_params = []
    for term in translation.param_terms:
        design_params.append(design_param_dict[term])
    design_params = tuple(design_params)

    # metrarank is default
    # Make an error response for providing a method that is not in the approved list
    if args.optimizer in opt_methods:
        optimizer = args.optimizer
    elif args.optimizer is None:
        optimizer = "sum-of-metaranks"
    else:
        print("Invalid optimizer. Choose between {}.".format(opt_methods))
        exit()

    if args.energy:
        targetdG = args.energy
    elif 'toehold_energy' in parameters:
        targetdG = parameters['toehold_energy']
    else:
        targetdG = 7.7

    if args.deviation:
        deviation = args.deviation
    elif 'toehold_deviation' in parameters:
        deviation = parameters['toehold_deviation']
    else:
        deviation = 0.5

    if args.maxspurious:
        max_spurious = args.maxspurious
    elif 'toehold_spurious' in parameters:
        max_spurious = parameters['toehold_spurious']
    else:
        max_spurious = 0.4

    if args.candidates:
        n = args.candidates
    elif 'n' in parameters:
        n = parameters['n']
    else:
        n = 4

    if args.extrapars:
        extra_pars = args.extrapars
    elif 'spurious_design_parameters' in parameters:
        extra_pars = parameters['spurious_design_parameters']
    else:
        extra_pars = ""

    energyfuncs = translation_scheme.energetics.energyfuncs(targetdG=targetdG,
                                         length=toehold_length,
                                         deviation=deviation,
                                         max_spurious=max_spurious)


    out = run_designer(basename,
                     reps=n,
                     design_params=design_params,
                     translation=translation,
                     optimizer=optimizer,
                     energyfuncs=energyfuncs,
                     extra_pars=extra_pars,
                     quick=args.quick,
                     debug=args.debug)
    winner = out[2]
    if winner is None:
        return None
    else:
        print('Winning sequence set is index {}'.format(winner))
        print('Find this sequence data in the file {}{}.seqs'.format(basename, winner))
        print('The table of scores from this session is in the file {}_scores.csv'.format(basename))
        print('Results of the candidate selection are found in {}_score_report.txt'.format(basename))

def get_score_parser():
    import argparse
    descr = "piperine-score is Piperine's command line utility for scoring a sequence set implementing a CRN."
    usage = "\n\n\n\
The following is the call template with short option flags. Options are shown in brackets. Capitalized terms stand in for \
required argument or multiple arguments.\n\
piperine-score CRNFILE FIXEDFILE [-e ENERGY] [-p DESIGNPARAMS ...] [-t TRANSLATION_SHEME] [-x EXTRAPARS] [-q] \n\n\
Default execution parameters are stated in the option descriptions. The following are example executions with CRN \
file my_very_own.crn, fixed file my.fixed, and option arguments to override the default settings. \n\
    \n\
    Score the sequence set according to the default translation scheme, Srinivas2017:\n \n\
    piperine-score my_very_own.crn my.fixed\n \
\n \
\n\
    Score another fixed file implemented using the Chen2013 translation scheme:\n\n\
    piperine-score my_very_own.crn chen2013_implementation.fixed -t Chen2013\n\
    or\n\
    piperine-score my_very_own.crn chen2013_implementation.fixed -translation_scheme Chen2013\n\n\n\
    Score the sequence set, but with a different intended toehold binding energy:\n\n\
    piperine-score my_very_own.crn my.fixed -e 9\n\
    "
    parser = argparse.ArgumentParser(description=descr, usage=usage)
    parser.add_argument("crnfile",
                        help='Text file describing CRN. May also define parameters.',
                        type=str)

    parser.add_argument("fixedfiles",
                        help='Text file containing sequence constraints. Files read or generated by ' +
                              'this call will have the form: basename.extension ; '+
                          'E.g. basename.fixed may generate basename_score.csv .',
                        nargs='+',
                        type=str)

    parser.add_argument("-e", "--energy",
                        help='Target toehold binding energy in kcal/mol. [default: 7.7]',
                        type=float)

    parser.add_argument("-p", '--designparams',
                        help='A string of integers that are parameters to the compiling the PIL file from the '+
                             ' system file (.sys extension). [default: Finds in module]',
                        type=int,
                        nargs="*")

    parser.add_argument("-t", '--translation_scheme',
                        help='Provide a string, the name of the Python package describing the translation scheme used to convert '+
                            'the CRN to DNA strands and complexes. See piperine.Srinivas2017 for an example of such a package.'+
                            ' [default: Srinivas2017]',
                        type=str)

    parser.add_argument("-q", '--quick',
                        action='store_true',
                        help='Make random numbers instead of computing heuristics to save time. [default: False]')

    parser.add_argument("-D", '--debug',
                        action='store_true',
                        help='Debugging mode that preserves intermediate compilation files. [default: False]')

    parser.add_argument("-f", '--filedestination',
                        help='Write the score table to this file rather [default: Write to stdout and do not create a file.]',
                        type=str)
    return parser

def score():
    '''
    Function called by the command line function 'piperine-score'
    '''
    parser = get_score_parser()
    args = parser.parse_args()

    ############## Interpret arguments.
    # Precedence is : command line arguments > crn file arguments > default
    assert(args.crnfile[-4:] == '.crn')
    crnfile = args.crnfile

    print(args.fixedfiles)
    if type(args.fixedfiles) is not list:
        fixedfiles = [args.fixedfiles]
    else:
        fixedfiles = args.fixedfiles

    # Read parameters from CRN file, only to see if translation scheme is defined
    parameters = get_parameters_from_crn_file(crnfile, None)

    # Import translation scheme package
    if args.translation_scheme:
        translation_scheme = importlib.import_module("."+args.translation_scheme, 'piperine')
    elif 'translation_scheme' in parameters:
        translation_scheme = importlib.import_module("."+parameters['translation_scheme'], 'piperine')
    else:
        translation_scheme = default_translation_scheme

    # Sorry for this horrible line. "translation_scheme" is a package that holds the
    # translation and energetics modules. "translation" is a module that provides the code
    # that generates PIL descriptions of the DNA implementation.
    translation = translation_scheme.translation

    # Make dictionary for design parameters. Start with default parameters
    design_param_dict = dict(zip(translation.param_terms, translation.default_params))

    # Get compilation parameters and define energetics instance.
    # This function uses the translation module to look for translation-specific parameters
    crn_file_parameters = get_parameters_from_crn_file(crnfile, translation)

    # Apply parameter option preference
    for term in translation.param_terms:
        if term in crn_file_parameters:
            design_param_dict[term] = crn_file_parameters[term]

    if args.designparams:
        design_param_dict = dict(zip(translation.param_terms, args.designparams))

    if args.designparams:
        toehold_length = design_param_dict[translation.toehold_length_term]
    elif 'toehold_length' in parameters:
        toehold_length = parameters['toehold_length']
    elif translation.toehold_length_term in parameters:
        toehold_length = parameters[translation.toehold_length_term]
    else:
        toehold_length = design_param_dict[translation.toehold_length_term]

    design_params = []
    for term in translation.param_terms:
        design_params.append(design_param_dict[term])
    design_params = tuple(design_params)

    if args.energy:
        targetdG = args.energy
    elif 'toehold_energy' in parameters:
        targetdG = parameters['toehold_energy']
    else:
        targetdG = 7.7

    energyfuncs = translation_scheme.energetics.energyfuncs(targetdG=targetdG,
                                         length=toehold_length)

    out = score_fixed(fixedfiles,
                      crnfile,
                      score_file=args.filedestination,
                      design_params=design_params,
                      translation=translation,
                      energyfuncs=energyfuncs,
                      quick=args.quick,
                      debug=args.debug)

def get_select_parser():
    import argparse
    descr = "piperine-score is Piperine's command line utility for selecting an optimal sequence set from score tables."
    usage = "\n\n\n\
Call template with short option flags. Options are shown in brackets. Capitalized terms stand in for \
required argument or multiple arguments.\n\
piperine-select SCORETABLES ... [-O OPTIMIZER] [-f FILE-DESTINATION] \n\n\
Default execution parameters are stated in the option descriptions."
    parser = argparse.ArgumentParser(description=descr, usage=usage)
    parser.add_argument("scoretables",
                        help='CSV files containing tables of heuristic score values.',
                        nargs='+',
                        type=str)

    parser.add_argument("-O", '--optimizer',
                        help='Method used by the selection process to choose the optimal candidate. Options are {}  \
                              . [default: sum-of-metaranks]'.format(opt_methods),
                        type=str)

    parser.add_argument("-f", '--filedestination',
                        help='Write the selection report to this file rather than to stdout. \
                              . [default: Write to stdout and do not create a file.]',
                        type=str)
    return parser

def select():
    '''
    Function called by the command line function 'piperine-select'
    '''
    from .selectseq import metarank
    parser = get_select_parser()
    args = parser.parse_args()

    ############## Interpret arguments.
    for tab in args.scoretables:
        assert(os.path.exists(tab))

    if args.optimizer:
        assert(args.optimizer in opt_methods)
        method = args.optimizer
    else:
        method = 'sum-of-metaranks'

    writeflag = False
    if args.filedestination:
        writeflag = True

    csvnames = args.scoretables

    columns_named=False
    scores = []
    for csvname in csvnames :
        print("Reading scores from "+csvname+" .")

        with open(csvname, 'r') as csvfile:
            score_reader = csv.reader(csvfile)
            for row in score_reader:
                #print(', '.join(row))
                if 'Winner' in row[0]:
                    continue
                if 'Index' in row[0] and columns_named:
                    continue
                else:
                    scores.append(row)
                    columns_named=True
            csvfile.close()

    print(scores)
    if writeflag:
        with Capturing() as output:
            winner = metarank(scores)
        with open(args.filedestination, 'w') as f:
            for line in output:
                f.write(line+'\n')
    else:
        winner = metarank(scores)

    message = "Winning index is {} using method {}."
    print(message.format(winner, method))
